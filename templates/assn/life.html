<head>

	%include templates/parts/head.html

</head>
<body>

	<!-- Navigation Bar -->
	%include templates/parts/navBar.html

	<div class="container">
			
		<!-- Header -->
		<div class="row">
			<div class="col-sm-12">
				<div id="pageHeader">
					<h1>
						Assignment 1: The Game of Life
					</h1>

					<p>
						Thanks to Julie Zelenski for the idea and Jerry Cain, Keith Schwarz, Cynthia Lee and Marty Stepp for revisions.
					</p>
					

				</div>
				<hr/>
			</div>
		</div>

		<div class="row" style="margin-bottom:25px">
					<div class="col-sm-12">
				<p>
					<center>
						<img style="width:70%;" src="{{pathToRoot}}img/assn/life/life.png">	
						<p style="text-align:center; margin-bottom:15px"><i>A still image of the Game of Life</i></p>
					</center>
				</p>
			</div>
		</div>

		

		<div class="row">
			<div class="col-sm-9">
				<p>For your first assignment... We make the Game of Life! </p>
				<p>
					The purpose of this assignment is to gain familiarity with basic C++ features such as functions, strings, and I/O streams, using provided libraries, and decomposing a large problem into smaller functions. This is an individual assignment. You should write your own solution and not work in a pair on this program.

				</p>
				<p>
The Game of Life is a simulation originally conceived by the British mathematician J. H. Conway in 1970 and popularized by Martin Gardner in his Scientific American column. The game models the life cycle of bacteria using a two-dimensional grid of cells. Given an initial pattern, the game simulates the birth and death of future generations of cells using a set of simple rules. In this assignment you will implement a simplified version of Conway's simulation and a basic user interface for watching the bacteria grow over time.
				</p>
				<p>
					The starter code for this project is availible as a ZIP archive:
				</p>
					<a href="{{pathToRoot}}/assnFiles/life/cs106b-hw1-life-starter-files.zip"><span class="glyphicon glyphicon-save-file" aria-hidden="true" style="font-size: 5em;margin-left:5px"></span><br/>
					Starter Code</a>
			</div>
			<div class="col-sm-3">
				<div class="well info faq">
					<b>Due Date:</b> Life is due January 15th at 5:00pm.
				</div>
				<div class="well info faq">
					<b>Submit:</b> You can submit multiple times. We will grade your latest submission.
				</div>
				<div class="well info faq" style="margin-bottom:5px;">
					<b>More about Life:</b> <a href="https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life">Wikipedia</a><br/> 
					<a href="http://blog.stephenwolfram.com/2015/12/what-is-spacetime-really/">Life and space-time</a>.
				</div>
			</div>
		</div>

		<div class="row">
			<div class="col-sm-12">
				<hr/>
			</div>
		</div>

		<div class="row">
			<div class="col-sm-12">
				<h2>
					Overview
				</h2>
				<p>
					Your Game of Life program should begin by prompting the user for a file name and using that file's contents to set the initial state of your bacterial colony grid. Then it will allow the user to advance the colony through generations of growth. The user can type t to "tick" forward the bacteria simulation by one generation, or a to begin an animation loop that ticks forward the simulation by several generations, once every 50 milliseconds; or q to quit. Your menu should be case-insensitive; for example, an uppercase or lowercase A, T, or Q should work.

				</p>
			</div>
		</div>
		<div class="row">
			<div class="col-sm-6">
				<h4 class="secondHeading">Simple Example:</h4>
				<p>
					Here is an example log of interaction between your program and the user (with console input in blue). 
				</p>
				<p>
					<img src = "{{pathToRoot}}/img/assn/life/lifeDemo.png" style="max-width:300px"></img>
				</p>
			</div>
			<div class="col-sm-6">
				<h4 class="secondHeading">Many Examples:</h4>
				<p>
					Of course there are many other interactions you could have. Here is a bunch more examples. They show what to do in many cases, for example bad input filenames.
				</p>
				<div class="row">
					<div class="col-sm-4">
						<a href="{{pathToRoot}}assnFiles/life/output/expected-output-1.txt"><span class="glyphicon glyphicon-list-alt" aria-hidden="true" style="font-size: 5em;margin-left:10px"></span><br/>
								Example Run #1</a>
					</div>
					<div class="col-sm-4">
						<a href="{{pathToRoot}}assnFiles/life/output/expected-output-2.txt"><span class="glyphicon glyphicon-list-alt" aria-hidden="true" style="font-size: 5em;margin-left:10px"></span><br/>
								Example Run #2</a>
					</div>
					<div class="col-sm-4">
						<a href="{{pathToRoot}}assnFiles/life/output/expected-output-3.txt"><span class="glyphicon glyphicon-list-alt" aria-hidden="true" style="font-size: 5em;margin-left:10px"></span><br/>
								Example Run #3</a>
					</div>
				</div>
				<div style="height:15px"></div>
				<div class="row">
					<div class="col-sm-4">
						<a href="{{pathToRoot}}assnFiles/life/output/expected-output-4.txt"><span class="glyphicon glyphicon-list-alt" aria-hidden="true" style="font-size: 5em;margin-left:10px"></span><br/>
								Example Run #4</a>
					</div>
					<div class="col-sm-4">
						<a href="{{pathToRoot}}assnFiles/life/output/expected-output-5.txt"><span class="glyphicon glyphicon-list-alt" aria-hidden="true" style="font-size: 5em;margin-left:10px"></span><br/>
								Example Run #5</a>
					</div>
					<div class="col-sm-4">
						<a href="{{pathToRoot}}assnFiles/life/output/expected-output-6.txt"><span class="glyphicon glyphicon-list-alt" aria-hidden="true" style="font-size: 5em;margin-left:10px"></span><br/>
								Example Run #6</a>
					</div>
				</div>
				<div style="height:15px"></div>
				<div class="row">
					<div class="col-sm-12">
							When ready, compare your programs to these "Example Runs" using the Example Diff Tool. We want your output to match ours exactly:
						
						<center style="margin-top:5px">
						<a href="{{pathToRoot}}handouts/diff.html"><span class="glyphicon glyphicon-check" aria-hidden="true" style="font-size: 5em;"></span><br/>
								Example Diff Tool</a>
							</center>
					</div>
				</div>
				
			</div>
		</div>

		<div class="row">
			<div class="col-sm-12">
				<hr/>
			</div>
		</div>
		
		<div class="row">
			<div class="col-sm-12">
				<h2>
					Files
				</h2>
				<p>
					You will turn in only the following files:
				</p>
				<ol>
					<li><code>life.cpp</code>, the C++ code for the Game of Life simulation</li>
					<li><code>mycolony.txt</code>, your own unique Game of Life input file representing a bacterial colony's starting state</li>
				</ol>
				<p>
					The ZIP archive contains other files and libraries; you should not modify these. When grading/testing your code, we will run your life.cpp with our own original versions of the support files, so your code must work with them.
				</p>
				<hr/>
			</div>
		</div>

		<div class="row">
			<div class="col-sm-12">
				<h2>
					Game of Life Simulation Rules
				</h2>
			</div>
		</div>
		<div class="row">
			<div class="col-sm-9">
				<p>
					Each grid location is either empty or occupied by a single living cell (X). A location's neighbors are
any cells in the surrounding eight adjacent locations. In the example at right, the shaded middle
location has three neighbors containing living cells. A square that is on the border of the grid has
fewer than eight neighbors. For example, the top-right X square in the example at right has only three neighboring squares, and only one of them contains a living cell (the shaded square), so it has one living neighbor.
				</p>
			</div>
			<div class="col-sm-3">
				<img src="{{pathToRoot}}/img/assn/life/eg0.png" style="max-width:115px; float:right"></img>
			</div>
		</div>
		<div class="row">
			<div class="col-sm-12">
				<p>
					The simulation starts with an initial pattern of cells on the grid and computes successive generations of cells according to the following rules:
				</p>
				<ol>
					<li>A location that has zero or one neighbors will be empty in the next generation. If a cell was there, it dies.</li>
					<li>A location with two neighbors is stable. If it had a cell, it still contains a cell. If it was empty, it's still empty.</li>
					<li>A location with three neighbors will contain a cell in the next generation. If it was unoccupied before, a new cell is born. If it currently contains a cell, the cell remains.</li>
					<li>
						A location with four or more neighbors will be empty in the next generation. If there was a cell in that location, it dies of overcrowding.
					</li>
				</ol>
				<p>
					The births and deaths that transform one generation to the next all take effect simultaneously. When you are computing a new generation, new births/deaths in that generation don't impact other cells in that generation. Any changes (births or deaths) in a given generation k start to have effect on other neighboring cells in generation k+1.

				</p>
				<p>
					Check your understanding of the game rules by looking at the following example. The two patterns should alternate forever:
				</p>
				<p>
					<img src="{{pathToRoot}}/img/assn/life/eg1.png" style="max-width:400px"></img>
				</p>
				<p>
					Here is a second example. The pattern at right does not change on each iteration, because each cell has exactly three living neighbors. This is called a "stable" pattern or a "still life".
				</p>
				<p>
					<img src="{{pathToRoot}}/img/assn/life/eg2.png" style="max-width:182px"></img>
				</p>
				<hr/>
			</div>
		</div>

		<div class="row">
			<div class="col-sm-12">
				<h2>
					Input Grid Data Files:
				</h2>
				<p>
					The grid of bacteria in your program gets its initial state from one of a set of provided input text files, which follow a particular format. When your program reads the grid file, you should re-prompt the user if the file specified does not exist. If it does exist, you may assume that all of its contents are valid. You do not need to write any code to handle a misformatted file. The behavior of your program in such a case is not defined in this spec; it can crash, it can terminate, etc. You may also assume that the input file name typed by the user does not contain any spaces.
				</p>
				<p>
					In each input file, the first two lines will contain integers r and c representing the number of rows and columns in the grid, respectively. The next lines of the file will contain the grid itself, a set of characters of size r x c with a line break (\n) after each row. Each grid character will be either a '-' (minus sign) for an empty dead cell, or an 'X' (uppercase X) for a living cell. The input file might contain additional lines of information after the grid lines, such as comments by its author or even junk/garbage data; any such content should be ignored by your program.
				</p>
				<p>The input files will exist in the same working directory as your program. For example, the following text might be the contents of a file simple.txt, a 5x9 grid with 3 initially live cells:</p>
				<pre>5                   &larr; <i>number of rows tall</i>
9                   &larr; <i>number of columns wide</i>
---------
---------           &larr; <i>- is a dead cell</i>
---XXX---           &larr; <i>X is a living cell</i>
---------
---------</pre>
			</div>
		</div>
				
		<div class="row">
			<div class="col-sm-12">
				<h2>
					Implementation Details
				</h2>
				<p>
					Grid: The grid of bacterial cells could be stored in a 2-dimensional array, but arrays in C++ lack some features and are generally difficult for new students to use. They do not know their own length, they cause strange bugs if you try to index out of the bounds of the array, and they require understanding C++ topics such as pointers and memory allocation. So instead of using an array to represent your grid, you will use an object of the Grid class, which is part of the provided Stanford C++ library.
				</p>
				<p>
					A Grid object offers a cleaner abstraction of a 2-dimensional data set, with several useful methods and features. See the course lecture examples and/or section 5.1 of the Programming Abstractions in C++ textbook for a list of members of the Grid class. You can also use the = assignment operator to copy the state of one Grid object to another.
				</p>
				<p>
					Your main function should create your Grid and pass it to the other functions. Since it is expensive to make copies of a Grid, if your code passes a Grid object as a parameter from one function to another, it should always do so by reference (Grid&, not Grid). See the lecture notes for examples. Since you don't know the size of the grid until you read the input file, you can call resize on the Grid object once you know the proper size.
				</p>
				<p>
					I/O: Your program has a console-based user interface. You can produce console output using cout and read console input using cin. You may use the Stanford C++ library's console-related functions such as getLine (uppercase L) to read from the console. See the Stanford C++ library documentation on the class web site.

				</p>
				<p>
					You will also write code for reading input files. Read a file using an ifstream object, along with functions such as getline (lowercase L) to read lines from the file. Here are some useful ifstream-related functions from <a href="http://stanford.edu/~stepp/cppdoc/filelib.html">filelib</a> and <a href="http://stanford.edu/~stepp/cppdoc/strlib.html">strlib</a>:
				</p>
				<table class="table table-bordered" style="font-size: 14px;">
					<thead>
					<tr>
					    <th style="width:380px">Command</th>
					    <th>Description</th> 					  </tr>
					<tr>
					</thead>
						<td>
							<code>openFile(ifstream &amp; stream, string filename);</code>
						</td>
						<td>
							Opens the file with the given filename/path and stores it into the given ifstream output parameter.
						</td>
					</tr>
					<tr>
						<td>
							<code>getline(ifstream &amp;  stream, string &amp; line);</code>
						</td>
						<td>
							Reads a line from the given stream and stores it into the given string variable by reference.
						</td>
					</tr>
					<tr>
						<td>
							<code>fileExists(string &amp; fileName);</code>
						</td>
						<td>
							Checks if a file with the corresponding fileName exists. Returns a bool.
						</td>
					</tr>
					<tr>
						<td>
							<code>stringToInteger(str)</code>
						</td>
						<td>
							Returns an int value equivalent to the given string; for example,"42" &rarr; 42
						</td>
					</tr>
					<tr>
						<td>
							<code>integerToString(n)
							</code>
						</td>
						<td>
							Returns a string value equivalent to the given integer; for example,42 &rarr; "42"
						</td>
					</tr>
				</table>
				<p>
					Make sure to close your input file streams when you are done reading the given file: stream.close().

				</p>

				<p>
					Checking for valid input: Note that your program needs to check for valid user input in a few places. When the user types the grid input file name, you must ensure that the file exists, and if not, you must re-prompt the user to enter a new file name. If the user is prompted to enter an action such as 't' for tick or 'a' for animate, if the user types anything other than the three predefined commands of a, t, or q (case-insensitively), you should re-prompt the user to enter a new command. If the user is prompted to enter an integer such as the number of frames of animation for the 'a' command, your code should re-prompt the user if they type a non-integer token of input. (If they do type an integer, you may assume that it is a valid value greater than 0; you don't need to explicitly test or check its value.) See the expected output files on the class web site for examples of this output. There are several functions from the Stanford C++ library that can help you with this functionality, such as fileExists and getInteger.
				</p>

				<p>
					Animation: When the user selects the animation option, the console output should look like the following:
				</p>
				<pre>a)nimate, t)ick, q)uit? <span class="input">a</span>
How many frames? <span class="input">xyz</span>
Illegal integer format. Try again.
How many frames? <span class="input">5</span>
(five new generations are shown, with screen clear and 50ms pause before each)</pre>
				<p>
					It is hard to show an example of animation output in this handout because the output does not translate well to a plain-paper format. The screen is supposed to clear between each generation of cells, leading to what looks like a smooth animation effect. Run the Sample Solution from the class web site to see how animation should work.
				</p>
				<p>
					To help you perform animation, use the following global functions from the Stanford C++ library:
				</p>

				<table class="table table-bordered" style="font-size: 14px;">
					<thead>
					<tr>
					    <th style="width:200px">Command</th>
					    <th>Description</th> 					  </tr>
					<tr>
					</thead>
						<td>
							<code>pause(ms);</code>
						</td>
						<td>
							Causes the program to halt execution for the given number of milliseconds
						</td>
					</tr>
					<tr>
						<td>
							<code>clearConsole();</code>
						</td>
						<td>
							Erases all currently visible text from the output console (call this between frames)
						</td>
					</tr>
				</table>

				<hr/>
			</div>
		</div>

		<div class="row">
			<div class="col-sm-12">
				<h2>
					Creative Aspect (mycolony.txt):
				</h2>
				<p>
					Along with your program, submit a file mycolony.txt that contains a valid initial colony that can be used as input. This can be anything you want, as long as it is in the input grid file format described in this document, and should be your own work (not just a copy of an existing colony input file). This is worth a small part of your grade.
				</p>
				<hr/>
			</div>
		</div>

		<div class="row">
			<div class="col-sm-12">
				<h2>
					Development Strategy and Hints:
				</h2>
				<p>
					Development strategy: It is tempting to try to write your entire program and then try to compile and run it; we do not recommend that strategy. Instead, you should develop your program incrementally: Write a small piece of functionality, then test/debug it until it works, then move on to another small piece. This way you are always making small consistent improvements to a base of working code. Here is a possible list of steps to develop a solution:
				</p>
				<ol>
					<li>Intro: Get your basic project running, and write code to print the introductory welcome message.</li>
					<li>File input: Write code to prompt for a filename, and open and print that file's lines to the console. Once this works, try reading the individual grid cells and turning them into a Grid object. Print the Grid's state on the console using toString just to see if it has the right data in it. Use a simple test case, e.g. simple.txt.</li>
					<li>Grid display: Write code to print the current state of the grid, without modifying that state.</li>
					<li>Updating to next generation: Write code to advance the grid from one generation to the next.This is one of the hardest parts of the assignment, so you will probably need lots of testing and debugging before it works perfectly. Insert cout statements to print important values as you go through your loops and code. Try printing out what indexes your code is examining, along with your count of how many neighbors each cell has, to make sure you are counting them properly.</li>
					<li>Overall menu and animation: Implement the program's main menu and the animation feature. If all of the preceding steps are finished and work properly, this should not be as difficult to get working.</li>
				</ol>
				<p>
					Updating from one generation to the next: When you are trying to advance the bacteria from one generation to the next, you cannot do this "in place" by modifying your grid as you loop over it. Doing so will change the cells and their neighbors and break the neighbor counts for nearby cells. So you will need to create a temporary second grid. Your existing grid represents the current generation of bacteria, and you can create a second temporary second grid that allows you to compute and store the next generation without changing the current one. Once you have filled the second grid with the next generation's cell information, you can copy its contents back into the original grid and discard the temporary copy. Copying one Grid to another is easy; just assign one to the other using the = assignment operator, which makes a copy of its contents.
				</p>
				<p>
					Output: We want your output to match ours exactly. This includes identical spacing, such as the extra spaces after the phrase, "Grid input file name? " Some students lose points for minor output formatting errors. Please run the web Output Comparison Tool on several test cases to make sure it matches without any differences.
				</p>
				<p>
					Hints: Here are some other miscellaneous tips that may help you:
				</p>
				<ol>
					<li>You can convert between strings and integers using functions stringToInteger and integerToString.</li>
					<li>You can re-prompt for a file name using the library function promptForFileName.</li>
					<li>A common bug when counting neighbors of a given cell is to count that cell itself. Don't do that.</li>
					<li>If your editor is unable to compile your program, complaining about "cannot open output file ...: Permission denied", you need to close/terminate all windows from previous runs of the program.</li>
				</ol>
				<hr/>
			</div>
		</div>



		<div class="row">
			<div class="col-sm-12">
				<h2>
					Possible Extra Features:
				</h2>
				<p>Thats all! You are done. Consider adding extra features.</p>
				<button id="extensionButton" type="button" class="btn btn-primary btn-lg" onclick='$("#extension").show();$("#extensionButton").hide();'>Show Extensions</button>
				<div id="extension" style="display:none">
				<p>
					Though your solution to this assignment must match all of the specifications mentioned previously, it is allowed and encouraged for you to add extra features to your program if you'd like to go beyond the basic assignment. Here are some example ideas for extra features that you could add to your program.
				</p>
				<ol>
					<li><b>Wrap-around:</b> The typical version of the assignment treats the edges of the grid as the end of the game world.  Modify your game logic so that the right-most squares are considered to be "neighbors" of the left-most, and the top-most are considered to be "neighbors" of the bottom-most.  This will allow moving patterns such as "gliders" to wrap around indefinitely.</li>
					<li><b>Random world generation:</b> Add special logic so that when the user is prompted for an input file name, if they type the word "random", instead of loading your input from a file, your program will randomly generate a game world of a given random size.  That is, your code will randomly pick a grid width and height (of at least 1), and then randomly decide whether to make each grid cell initially living or dead.  This way you can generate infinite possibilities of new game worlds each time you run the program.</li>
					<li><b>Graphical display:</b> The default version of the assignment displays its output as text.  But we also provide a file called life-gui.cpp that contains an implementation of a graphical display of the Life game world.  For this feature, insert code into your program that uses life-gui.  Here are the functions you can call:
						<table class="table table-bordered" style="font-size: 14px;">
							<thead>
							<tr>
							    <th style="width:240px">Command</th>
							    <th>Description</th> 					  </tr>
							<tr>
							</thead>
								<td>
									<code>LifeGUI name;</code>
								</td>
								<td>
									creates a new graphical user interface (GUI) window
								</td>
							</tr>
							<tr>
								<td>
									<code>gui.resize(nRows, nCols);</code>
								</td>
								<td>
									Sets the GUI to use the given number of rows/cols in its grid
								</td>
							</tr>
							<tr>
								<td>
									<code>gui.drawCell(r, c, alive);
</code>
								</td>
								<td>
									Tells the GUI whether the cell in the given row/column index is alive (true) or dead (false); living cells are drawn in color on the GUI.  If you call drawCell on a previously-living cell and pass false for alive, the GUI slowly "fades out" that cell with each generation
								</td>
							</tr>
						</table>

					</li>
					<li><b>GUI enhancements:</b> Do you want to add a feature to the provided graphical interface?  If so, tweak the provided GUI files and submit them with your turnin.  We haven't taught about GUI programming, but if you want to look at the provided files and learn how they work, we encourage you to do so.</li>
					<li><b>Other:</b> If you have your own creative idea for an extra feature, ask your SL and/or the instructor about it.</li>
				</ol>
				<h4 class="secondHeading">Indicating that you have done extra features:</h4>
				<p>
					 If you complete any extra features, then in the comment heading on the top of your program, please list all extra features that you worked on and where in the code they can be found (what functions, lines, etc. so that the grader can look at their code easily).
				</p>
				<h4 class="secondHeading">Submitting a program with extra features:</h4>
				<p>Since we use automated testing for part of our grading process, it is important that you submit a program that conforms to the preceding spec, even if you want to do extra features. If your feature(s) cause your program to change the output that it produces in such a way that it no longer matches the expected sample output test cases provided, you should submit two versions of your program file: a first one named life.cpp without any extra features added (or with all necessary features disabled or commented out), and a second one named life-extra.cpp with the extra features enabled. Please distinguish them in by explaining which is which in the comment header. Our turnin system saves every submission you make, so if you make multiple submissions we will be able to view all of them; your previously submitted files will not be lost or overwritten.</p>
			</div>

			</div>
		</div>


		%include templates/parts/footer.html

	</div>

</body>
