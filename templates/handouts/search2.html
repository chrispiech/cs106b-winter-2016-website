<head>

	%include templates/parts/head.html

	<script src="{{pathToRoot}}js/queue.js"></script>

</head>
<body>

	<!-- Navigation Bar -->
	%include templates/parts/navBar.html

	<div class="container">
			
		<!-- Header -->
	<div class="row">
		<div class="col-sm-12">
			<div id="pageHeader">
				<h1>
					Search
				</h1>
			</div>
			<hr/>
		</div>
	</div>

	<div class="row">
		<div class="col-sm-12">
      <p>
			<button type="button" class="btn btn-primary" onclick="randomGraph();">Random Graph</button>
			<button type="button" class="btn btn-primary" onclick="runDFS();">Recursive Exploration</button>
			<button type="button" class="btn btn-primary" onclick="runDFS();">Depth First</button>
			<button type="button" class="btn btn-primary" onclick="runBFS();">Breadth First</button>
    </p>
		</div>
	</div>

	<div class="row">
		<div class="col-sm-12">
      <p>
			<canvas id="graphCanvas">
				Why you not have canvas?
			</canvas>
    </p>
		</div>
	</div>

	<script>

    CANVAS_HEIGHT = 500
    CANVAS_WIDTH = 730
    N_POINTS = 500 //500
    EDGE_DIST = 40 //40
    INSET = 5
    ANIMATION_PAUSE = 10

		points = {}
    graph = {}
    startId = null;
    endId = null;
    canvas = null;
    ctx = null;
    fresh = false;
    timeout = null;

    function Point(x, y){
      this.x = x || 0;
      this.y = y || 0;
    };

		window.onload = function() {
      initCanvas();
      randomGraph();
		}

    function initCanvas() {
      canvas = $('#graphCanvas')[0]
      ctx = canvas.getContext("2d");
      $('#canvas').height(CANVAS_HEIGHT);
      canvas.width = CANVAS_WIDTH;
      canvas.height = CANVAS_HEIGHT;
      
    }

    function getDist(point1, point2) {
      var dx = point1.x - point2.x;
      var dy = point1.y - point2.y;
      return Math.sqrt(dx * dx + dy * dy);
    }

    function randomIndex(arr) {
      return Math.floor(arr.length * Math.random())
    }

    function randomChoice(arr) {
      return arr[randomIndex(arr)];
    }

    function deepCopy(arr) {
      var newArr = []
      for(var i = 0; i < arr.length; i++) {
        newArr.push(arr[i]);
      }
      return newArr;
    }

    function drawCircle(pt, radius, color) {
      ctx.fillStyle=color;
      ctx.beginPath();
      ctx.arc(pt.x, pt.y, radius, 0, 2 * Math.PI, false);
      ctx.fill();
    }

    function drawLine(pt1, pt2, color) {
      ctx.strokeStyle = color;
      ctx.beginPath();
      ctx.moveTo(pt1.x, pt1.y);
      ctx.lineTo(pt2.x, pt2.y);
      ctx.stroke();
      
    }

    function highlightPath(path) {
      for(var i = 0; i < path.length; i++) {
        var nodeId = path[i];
        drawCircle(points[nodeId], 6, "red");
        if(i < path.length - 1) {
          var nextId = path[i + 1];
          drawLine(points[nodeId], points[nextId], "red");
        }
      }
    }


    seenDFS = {};

    function runDFS() {
      if(!fresh) drawGraph();
      fresh = false;
      stack = [];
      seenDFS = {};
      stack.push([startId])
      iterDFS(stack)
    }

    function iterDFS(stack) {
      if(stack.length == 0) return;
      var path = stack.pop();
      var nextId = path[path.length - 1];
      console.log(nextId)

      if(nextId in seenDFS) {
        iterDFS(stack);
        return;
      }
      seenDFS[nextId] = true;
      drawCircle(points[nextId], 4, "blue");
      if(path.length >= 2) {
        var prevId = path[path.length-2];
        drawLine(points[prevId], points[nextId], "blue");
      }
      if(nextId == endId) {
        highlightPath(path);
        return;
      }
      for(var i = 0; i < graph[nextId].length; i++) {
        var child = graph[nextId][i];
        var newPath = deepCopy(path);
        newPath.push(child);
        stack.push(newPath);
      }
      timeout = setTimeout(function(){iterDFS(stack)}, ANIMATION_PAUSE);
    }

    function runBFS() {
      if(!fresh) drawGraph();
      fresh = false;
      var queue = new Queue();
      var seen = {}
      var paths = []
      var found = false;
      queue.enqueue([startId]);
      while(!queue.isEmpty()) {
        var currPath = queue.dequeue();
        var nextId = currPath[currPath.length - 1];
        if(nextId in seen) continue;
        paths.push(currPath)
        if(nextId == endId) {
          found = true;
          break;
        }
        seen[nextId] = true;
        for(var i = 0; i < graph[nextId].length; i++) {
          var child = graph[nextId][i];
          var newPath = deepCopy(currPath);
          newPath.push(child);
          queue.enqueue(newPath);
        }
      }
      animate(paths, function() {
        if(found) {
          var lastPath = paths[paths.length - 1];
          highlightPath(lastPath);
        } 
      })
    }

    function animate(paths, callback) {
      var index = 0
      timeout = setTimeout(function() {
        var path = paths[index];
        console.log(path)
        if(path.length >= 2) {
          var id1 = path[path.length-2]
          var id2 = path[path.length-1]
          drawLine(points[id1], points[id2], "blue");
        }
        var lastId = path[path.length - 1]
        drawCircle(points[lastId], 4, "blue");
        index++;
        if(index < paths.length) {
          timeout = setTimeout(arguments.callee, ANIMATION_PAUSE);
        } else {
          callback();
        }
      }, ANIMATION_PAUSE);
    }

    function drawGraph() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      for(nodeId in graph) {
        for(var i = 0; i < graph[nodeId].length; i++) {
          var nextId = graph[nodeId][i];
          drawLine(points[nodeId], points[nextId], "#AAAAAA");
        }
      }

      for(var i = 0; i < N_POINTS; i++) {
        drawCircle(points[i], 2, "black")
      }
      drawCircle(points[startId], 10, "green")
      drawCircle(points[endId], 10, "red")

      fresh = true;
    }

		function randomGraph() {
      //get a reference to the canvas
      

      //clear graph and canvas
      clearTimeout(timeout);
      points = []
      graph = {}
      


			for(var i = 0; i < N_POINTS; i++) {
        var centerX = INSET + (canvas.width - INSET *2) * Math.random();
        var centerY = INSET + (canvas.height - INSET *2) * Math.random();
        var point = new Point(centerX, centerY);
        points[i] = point;
        graph[i] = []
			}
      startId = randomIndex(points);
      endId = randomIndex(points);

      for(var i = 0; i < N_POINTS; i++) {
        for(var j = 0; j < i; j++) {
          if(getDist(points[i], points[j]) < EDGE_DIST) {
            graph[i].push(j);
            graph[j].push(i);
          }
        }
      }

      drawGraph();
		}

	</script>
		
		
				
		


	

		%include templates/parts/footer.html

	</div>

</body>
