<head>

	%include templates/parts/head.html

	<script src="{{pathToRoot}}js/queue.js"></script>
	<script src="{{pathToRoot}}js/heapQueue.js"></script>

</head>
<body>

	<!-- Navigation Bar -->
	%include templates/parts/navBar.html

	<div class="container">
			
		<!-- Header -->
	<div class="row">
		<div class="col-sm-12">
			<div id="pageHeader">
				<h1>
					Search
				</h1>
			</div>
			<hr/>
		</div>
	</div>

	
	<div class="row">
		<div class="col-sm-12">
      <p>
			<button type="button" class="btn btn-primary" onclick="runDFS();">Recursive Exploration</button>
			<button type="button" class="btn btn-primary" onclick="runDFS();">Depth First</button>
			<button type="button" class="btn btn-primary" onclick="runBFS();">Breadth First</button>
			<button type="button" class="btn btn-primary" onclick="runDijkstra();">Dijkstra</button>
			<!--<button type="button" class="btn btn-primary" onclick="runAStar();">A Star</button>-->
    </p>
		</div>
	</div>

	<div class="row">
		<div class="col-sm-12">
      <p>
			<button type="button" class="btn btn-info" onclick="unweightedGraph();">Unweighted Graph</button>
			<button type="button" class="btn btn-info" onclick="weightedGraph();">Weighted Graph</button>
		</p>
		</div>
	</div>

	<div class="row">
		<div class="col-sm-12">
	      <p>
				<canvas id="graphCanvas">
					Why you not have canvas?
				</canvas>
	    </p>
	    <h2>
	    	Path hops: <span id="hopsNum"></span>
	    </h2>
	    <h2>
	    	Path cost: <span id="costNum"></span>
	    </h2>
		</div>
	</div>

	<script>

    CANVAS_HEIGHT = 500
    CANVAS_WIDTH = 730
    INSET = 5
    ANIMATION_PAUSE = 10

	points = {}
    graph = {}
    weights = {}
    isWeighted = false;
    startId = null;
    endId = null;
    canvas = null;
    ctx = null;
    fresh = false;
    timeout = null;

    function Point(x, y){
      this.x = x || 0;
      this.y = y || 0;
    };

		window.onload = function() {
      initCanvas();
      unweightedGraph();
		}

    function initCanvas() {
      canvas = $('#graphCanvas')[0]
      ctx = canvas.getContext("2d");
      $('#canvas').height(CANVAS_HEIGHT);
      canvas.width = CANVAS_WIDTH;
      canvas.height = CANVAS_HEIGHT;
      
    }

    function getDist(point1, point2) {
      var dx = point1.x - point2.x;
      var dy = point1.y - point2.y;
      return Math.sqrt(dx * dx + dy * dy);
    }

    function randomIndex(arr) {
      return Math.floor(arr.length * Math.random())
    }

    function randomChoice(arr) {
      return arr[randomIndex(arr)];
    }

    function deepCopy(arr) {
      var newArr = []
      for(var i = 0; i < arr.length; i++) {
        newArr.push(arr[i]);
      }
      return newArr;
    }

    function drawCircle(pt, radius, color) {
      ctx.fillStyle=color;
      ctx.beginPath();
      ctx.arc(pt.x, pt.y, radius, 0, 2 * Math.PI, false);
      ctx.fill();
    }

    function drawLine(pt1, pt2, color) {
      ctx.strokeStyle = color;
      ctx.beginPath();
      ctx.moveTo(pt1.x, pt1.y);
      ctx.lineTo(pt2.x, pt2.y);
      ctx.stroke();
      
    }

    function highlightPath(path) {
      for(var i = 0; i < path.length; i++) {
        var nodeId = path[i];
        drawCircle(points[nodeId], 6, "red");
        if(i < path.length - 1) {
          var nextId = path[i + 1];
          drawLine(points[nodeId], points[nextId], "red");
        }
      }
      $("#hopsNum").html(path.length);
      $("#costNum").html(pathCost(path))
    }


    seenDFS = {};

    function runDFS() {
      if(!fresh) refresh();
      fresh = false;
      stack = [];
      seenDFS = {};
      stack.push([startId])
      iterDFS(stack)
    }

    function iterDFS(stack) {
      if(stack.length == 0) return;
      var path = stack.pop();
      var nextId = path[path.length - 1];
      console.log(nextId)

      if(nextId in seenDFS) {
        iterDFS(stack);
        return;
      }
      seenDFS[nextId] = true;
      drawCircle(points[nextId], 4, "blue");
      if(path.length >= 2) {
        var prevId = path[path.length-2];
        drawLine(points[prevId], points[nextId], "blue");
      }
      if(nextId == endId) {
        highlightPath(path);
        return;
      }
      for(var i = 0; i < graph[nextId].length; i++) {
        var child = graph[nextId][i];
        var newPath = deepCopy(path);
        newPath.push(child);
        stack.push(newPath);
      }
      timeout = setTimeout(function(){iterDFS(stack)}, ANIMATION_PAUSE);
    }

    function pathCost(path) {
    	if(!isWeighted) return path.length
    	var cost = 0
    	for(var i = 0; i < path.length-1; i++) {
    		var a = path[i]
    		var b = path[i + 1]
    		var key = a + "->" + b
    		var weight = weights[key]
    		cost += weight
    	}
    	return cost;
    } 

    function runBFS() {
      if(!fresh) refresh();
      fresh = false;
      var queue = new Queue();
      var seen = {}
      var paths = []
      var found = false;
      queue.enqueue([startId]);
      while(!queue.isEmpty()) {
        var currPath = queue.dequeue();
        var nextId = currPath[currPath.length - 1];
        if(nextId in seen) continue;
        paths.push(currPath)
        if(nextId == endId) {
          found = true;
          break;
        }
        seen[nextId] = true;
        for(var i = 0; i < graph[nextId].length; i++) {
          var child = graph[nextId][i];
          var newPath = deepCopy(currPath);
          newPath.push(child);
          queue.enqueue(newPath);
        }
      }
      animate(paths, function() {
        if(found) {
          var lastPath = paths[paths.length - 1];
          highlightPath(lastPath);
        } 
      })
    }

    function runDijkstra() {
    	if(!isWeighted) return runBFS();
    	if(!fresh) refresh();
		fresh = false;

		var pQueue = new HeapQueue(function(a, b){
		    // if b > a, return negative
		    // means that it spits out the smallest item first
		  return pathCost(a) - pathCost(b)
		})

		var seen = {}
		var paths = []
		var found = false;
		pQueue.push([startId]);
		while(pQueue.length != 0) {
			var currPath = pQueue.pop();
			var nextId = currPath[currPath.length - 1];
			if(nextId in seen) continue;
			paths.push(currPath)
			if(nextId == endId) {
			  found = true;
			  break;
			}
			seen[nextId] = true;
			for(var i = 0; i < graph[nextId].length; i++) {
			  var child = graph[nextId][i];
			  var newPath = deepCopy(currPath);
			  newPath.push(child);
			  pQueue.push(newPath);
			}
		}
		animate(paths, function() {
			if(found) {
			  var lastPath = paths[paths.length - 1];
			  highlightPath(lastPath);
			} 
		})
    }

    function animate(paths, callback) {
      var index = 0
      timeout = setTimeout(function() {
        var path = paths[index];
        console.log(path)
        if(path.length >= 2) {
          var id1 = path[path.length-2]
          var id2 = path[path.length-1]
          drawLine(points[id1], points[id2], "blue");
        }
        var lastId = path[path.length - 1]
        drawCircle(points[lastId], 4, "blue");
        index++;
        if(index < paths.length) {
          timeout = setTimeout(arguments.callee, ANIMATION_PAUSE);
        } else {
          callback();
        }
      }, ANIMATION_PAUSE);
    }

    function drawGraph() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      $("#hopsNum").html("");
    	$("#costNum").html("");

      for(nodeId in graph) {
        for(var i = 0; i < graph[nodeId].length; i++) {
          var nextId = graph[nodeId][i];
          drawLine(points[nodeId], points[nextId], "#AAAAAA");
        }
      }

      for(var i = 0; i < points.length; i++) {
        drawCircle(points[i], 2, "black")
      }
      drawCircle(points[startId], 10, "green")
      drawCircle(points[endId], 10, "red")

      fresh = true;
    }

    function drawWeights() {
    	ctx.font = "12px Courier";
	    ctx.fillStyle = "black"
	    console.log(weights)
	    for(nodeId in graph) {
	        for(var i = 0; i < graph[nodeId].length; i++) {
	        	var nextId = graph[nodeId][i];
	        	var midX = (points[nodeId].x + points[nextId].x) / 2;
	        	var midY = (points[nodeId].y + points[nextId].y) / 2;
	        	var key = nodeId + "->" + nextId
	        	var weight = weights[key];
	        	ctx.fillText(weight,midX,midY);
	        }
	    }
    }

    function unweightedGraph() {
    	isWeighted = false;
    	randomGraph(500, 40, 5);
    	drawGraph();
    }

    function weightedGraph() {
    	isWeighted = true;
    	randomGraph(25, 200, 100);
    	weights = {}
    	for(nodeId in graph) {
	        for(var i = 0; i < graph[nodeId].length; i++) {
	          var nextId = graph[nodeId][i];
	          var key1 = nodeId + "->" + nextId
	          var key2 = nextId + "->" + nodeId
	          if(!(key1 in weights)) {
	          	var d = getDist(points[nodeId], points[nextId])
	          	var m = 1 + Math.random() * 10;
	          	var dist = Math.ceil(d * m);
	          	weights[key1] = dist;
	          	weights[key2] = dist;
	          }
	        }
	    }

	    drawGraph();
	    drawWeights();
    }

    function isTooClose(point, i, minDist) {
    	for(var j = 0; j < i; j++) {
    		if(getDist(points[j], point) < minDist) {
    			return true;
    		}
    	}
    	return false;
    }

    function refresh() {
    	drawGraph();
    	if(isWeighted) {
    		drawWeights();
    	}
    }

	function randomGraph(nPoints, edgeDist, minDist) {
      //clear graph and canvas
      clearTimeout(timeout);
      points = []
      graph = {}
      for(var i = 0; i < nPoints; i++) {
        var centerX = INSET + (canvas.width - INSET *2) * Math.random();
        var centerY = INSET + (canvas.height - INSET *2) * Math.random();
        var point = new Point(centerX, centerY);
        if(minDist > 0) {
        	while(isTooClose(point, i, minDist)) {
        		centerX = INSET + (canvas.width - INSET *2) * Math.random();
        		centerY = INSET + (canvas.height - INSET *2) * Math.random();
        		point = new Point(centerX, centerY);
        	}
        }
        
        points[i] = point;
        graph[i] = []
	  }
      startId = randomIndex(points);
      endId = randomIndex(points);

      for(var i = 0; i < nPoints; i++) {
        for(var j = 0; j < i; j++) {
          if(getDist(points[i], points[j]) < edgeDist) {
	            graph[i].push(j);
	            graph[j].push(i);
          }
        }
      }
	}

	</script>
		
		
				
		


	

		%include templates/parts/footer.html

	</div>

</body>
